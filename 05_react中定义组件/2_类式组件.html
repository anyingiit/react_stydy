<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2_类式组件</title>
    <style>
    </style>
</head>
<body>

<div id="test"></div>

<script src="../js/react.development.js"></script>
<script src="../js/react-dom.development.js"></script>
<script src="../js/babel.min.js"></script>

<script type="text/babel">
  //1.创建类式组件
  class MyComponent extends React.Component {
    // [回顾]对于类A继承与B来说, 如果类A没有想要新添加的属性, 那么就不需要写构造器, 创建类A对象时需要填入类B构造器所需的参数, 其会自动调用类B的构造器并且将参数按顺序填入
    // render是放在哪里的? -- MyComponent的原型对象上, 供实例使用 <=> MyComponent组件实例对象
    render() {
      console.log('render中this: ', this)
      //输入能发现除了render以外还有很多的属性, 这是继承的功劳, 在React.Component的构造器方法中写入了属性(即this.props = {}; this.refs = {}, this.state = null ....)
      /*
        MyComponent {props: {…}, context: {…}, refs: {…}, updater: {…}, _reactInternalFiber: FiberNode, …}
        context: {}
        props: {}
        refs: {}
        state: null
        updater: {isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ}
        _reactInternalFiber: FiberNode {tag: 1, key: null, stateNode: MyComponent, elementType: ƒ, type: ƒ, …}
        _reactInternalInstance: {_processChildContext: ƒ}
        isMounted: (...)
        replaceState: (...)
        [[Prototype]]: Component
        */
      return <h2>我是用类定义的组件(适用于【复杂组件】的定义)</h2>
    }
  }

  //2.渲染组件到页面
  //(这里的render和上方定义组件时方法render没关系)
  ReactDOM.render(<MyComponent/>, document.getElementById('test'))
  /*
    执行了ReactDOM.render(<MyComponent />......之后, 发生了什么?
        1. React解析组件标签, 找到了MyComponent组件
        2. 发现组件是类定义的, 随后new出来该类的实例, 并通过该实例调用到原型上的render方法
        3. 将render返回的虚拟DOM转为真实DOM, 随后呈现在页面中
*/
</script>
</body>
</html>